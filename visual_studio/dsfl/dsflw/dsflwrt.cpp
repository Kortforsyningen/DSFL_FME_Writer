// Based on "DSFL Writer version 1.0 Build 8" - FME DSFL Writer by Lars Hansen (larsh@informi.dk), CDT 2002

#define VERSIONID "DSFLW2 Writer version 2.0 Build 1"

#include "dsflwrt.h"

#include <stdio.h> // for sprintf
#include <iostream>
#include <string>
#include <stdarg.h>
#include <float.h>
#include <afx.h>

// include the FME Developer Kit header files
#include <fmetypes.h>
#include <fmelog.h>
#include <fmecrd.h>
#include <fmemap.h>
#include <fmefeat.h>
#include <ifmeobjserv.h>
#include <servmgr.h>
#include <ifeatvec.h>
#include <isession.h>

// Error messages defined in DSFLWRT.FMS
const FME_MsgNum kMsgErrorOpening = 857550;
const FME_MsgNum kMsgFeatureType = 857551;
const FME_MsgNum kMsgUnsupportedFeatureType = 857552;
const FME_MsgNum kMsgHeaderHasBeenProcessed = 857553;
const FME_MsgNum kMsgInternalError = 857554;
const FME_MsgNum kMsgCantCreateTempFileName = 857555;
const FME_MsgNum kMsgCantCreateOutputFile = 857556;
const FME_MsgNum kMsgCantCreateTempOutputFile = 857557;
const FME_MsgNum kMsgStringFormatter= 857558;
const FME_MsgNum kMsgNoDSFLClass = 857559;
const FME_MsgNum kMsgNoDSFLSubClass = 857560;
const FME_MsgNum kMsgCantIdentifyFMEGeometry = 857561;
const FME_MsgNum kMsgUnsupportedPolygonGeometry = 857562;
const FME_MsgNum kMsgNoData = 857563;
const FME_MsgNum kMsgExpectedFMEAggregate = 857564;
const FME_MsgNum kMsgUnexpectedAggregateGeometry = 857565;
const FME_MsgNum kKmsgNoH3Attribute = 857566;
const FME_MsgNum kMsgExpectedFMEPointForDSFLText = 857567;
const FME_MsgNum kMsgMissingTextValue = 857568;
const FME_MsgNum kMsgMissingTextCode = 857569;
const FME_MsgNum kMsgMissingDsflOriginRecordIndex = 857570;
const FME_MsgNum kMsgDuplicateDsflOriginRecordIndex = 857571;


#ifdef WIN32
#define DLLEXPORT extern "C" __declspec(dllexport) 
#else
#define DLLEXPORT extern "C" 
#endif

static IFMELogFile* gLogFile = NULL;
static IFMEMappingFile* gMappingFile = NULL;
static IFMECoordSysManager* gCoordSysMan =NULL;
static IFMEServiceManager* gFMEServices = NULL;
static IFMEObjectsService* fmeObjectsService;
static IFMESession* fmeSession;


DLLEXPORT const char* FME_apiVersion()
{
    return kFMEDevKitVersion;
}

// TODO - This method is not called until after a while 
DLLEXPORT FME_MsgNum FME_initialize(IFMEServiceManager &serviceManager)
{
   // Store our service manager for later.
   gFMEServices = &serviceManager;

   	// Also get (and save) pointers to IFMEObjectsService and FME Session
	fmeObjectsService = (IFMEObjectsService*) (gFMEServices->getService(FME_SERV_FMEOBJECTS));
	fmeObjectsService->getSession(fmeSession);

	
   return 0;
}
//=====================================================================
// This method is used to reliably get a session for use by this
// plug-in.
//
DLLEXPORT void FME_acceptSession(IFMESession* ifmeSession)
{
   // This is a pointer only and does not take ownership.
   fmeSession = ifmeSession;
   FMEString::setSession(fmeSession);
   FMEStringArray::setSession(fmeSession);
}

// Log helper
void _cdecl Msg(const FME_MsgNum messageNumber, const char* fmt, ...)
{
	char Buffer[1024];
	va_list ap;
	va_start(ap,fmt);
	vsprintf(Buffer,fmt,ap);
	va_end(ap);
	FMEString S(Buffer);
	FMEStringArray A;
	A->append(S);
	gLogFile->logMessage(messageNumber,*A);
}

DLLEXPORT FME_MsgNum FME_createWriter(IFMELogFile& logFile,
                                      IFMEMappingFile& mappingFile,
                                      IFMECoordSysManager& coordSysMan,
                                      IFMEWriter*& writer,
                                      const char* writerTypeName,
                                      const char* writerKeyword)
{
    // First, keep the references to the FME-owned objects
    // so we can use them later in this module
    gLogFile = &logFile;
    gMappingFile = &mappingFile;
    gCoordSysMan = &coordSysMan;

	// Create Writer
	
	// When directives are generated by fmeworkbench they are named writerkeyword_directive
	// I guess the convention has been to write directives in mapping files as writertypenamedirective...
	// Appending the underscore (_) to the keyword here should make both scenarios valid
	std::string s(writerKeyword);
	s += "_";
	writer = new DSFLWriter(s.c_str(),writerKeyword);

    return 0;
}

DLLEXPORT FME_MsgNum FME_destroyWriter(IFMEWriter*& writer)
{
	// Delete FME session before deleting the writer
	fmeObjectsService->destroySession(fmeSession);
    
	// The delete the writer
	delete writer;
    writer = NULL;
    return 0;
}

IFMEFeatureVector* DSFLWriter::CreateFeatureVector()
{
	return fmeSession->createFeatureVector();	
}

void DSFLWriter::NukeFeatureVector(IFMEFeatureVector* V)
{	
	fmeSession->destroyFeatureVector(V);
}

DSFLWriter::DSFLWriter(const char* writerTypeName, const char* writerKeyword)
        :   writerTypeName_(writerTypeName),
		writerKeyword_(writerTypeName)
{
	// Set state information
	m_bHeaderAlreadyProcessed = false;
}

void DSFLWriter::ResetBBox()
{
	m_Xmin = DBL_MAX;
	m_Ymin = DBL_MAX;
	m_Zmin = DBL_MAX;
	m_Xmax = -m_Xmin;
	m_Ymax = -m_Ymin;
	m_Zmax = -m_Zmin;
	m_bPointProcessed = false;
}

void DSFLWriter::ExpandBBox(double X, double Y, double Z)
{
	m_Xmin = __min(m_Xmin,X);
	m_Ymin = __min(m_Ymin,Y);
	m_Zmin = __min(m_Zmin,Z);
	m_Xmax = __max(m_Xmax,X);
	m_Ymax = __max(m_Ymax,Y);
	m_Zmax = __max(m_Zmax,Z);
	m_bPointProcessed = true;
}
	
// Process an incoming dsfl_origin record
FME_MsgNum DSFLWriter::ProcessDSFLOrigin(const IFMEFeature& feature)
{
	// Must find a dsfl_origin_record_index
	FMEString fmsStr;
	if (!feature.getAttribute("dsfl_origin_record_index",*fmsStr)) return kMsgMissingDsflOriginRecordIndex;
	
	// Convert into MFC string
	CString Index(*fmsStr);

	// Now check if we have already processed this index
	CString Value;
	if (m_OriginInfo.Lookup(Index,Value)) return  kMsgDuplicateDsflOriginRecordIndex;

	// Begin creating the final DSFL output
	CString DSFLOutput = "%RN "+Index+"\n"; // Output format is %RN <Index>

	// Get all attributes
	FMEStringArray AllAttributes;
	feature.getAllAttributeNames(*AllAttributes);

	// Must sort the ND attributes
	CStringArray OriginArray;
	
	// Iterate and extract all %dsfl_origin_ND attributes
	for (unsigned int i = 0; i<AllAttributes->entries(); i++)
	{

		// Check if we care about the attribute
		CString AttributeName(*(AllAttributes->elementAt(i)));
		if (AttributeName.GetLength()>14)
		{
			if (AttributeName.Left(14).CompareNoCase("dsfl_origin_ND")==0)
			{
				// Got an ND attribute - get value and add to output
				if (!feature.getAttribute(AttributeName,fmsStr)) return kMsgInternalError;
				CString Value(*fmsStr);

				// Extract the ND part and add to the sorted array
				CString Output = "%"+AttributeName.Mid(12)+" "+Value+"\n";

				if (OriginArray.GetSize()==0)
				{
					// First entry
					OriginArray.Add(Output);
				}
				else
				{
					// Do an inserting sort
					bool inserted = false;
					for (int i = 0; i<OriginArray.GetSize(); i++)
					{
						if (OriginArray[i].CompareNoCase(Output)>=0)
						{
							OriginArray.InsertAt(i,Output);
							inserted = true;
							break;
						}
					}
					if (!inserted) OriginArray.Add(Output);
				}
			}
		}
	}

	// Add the complete sorted array to the DSFL output
	for (int i = 0; i<OriginArray.GetSize(); i++)
	{
		DSFLOutput+=OriginArray[i];
	}

	// Add complete origin info to dynamic map
	m_OriginInfo.SetAt(Index,DSFLOutput);

	return 0;
}

FME_MsgNum DSFLWriter::ProcessDSFLHeader(const IFMEFeature& feature)
{
	// Save all attributes and set flag to indicate that we have found a header
	if (m_bHeaderAlreadyProcessed) return kMsgHeaderHasBeenProcessed;

	// Start by saving the coordinate order (used when writing the header bounding box)
	// We must have this attribute
	FMEString Order;
	if (!feature.getAttribute("H3",*Order)) return kKmsgNoH3Attribute;
	m_CoordinateOrder = CString(*Order);

	// Get list of all attribute names and iterate to build list of all attribute values
	feature.getAllAttributeNames(m_HeaderAttributeNames);
	
	for (unsigned int i = 0; i<m_HeaderAttributeNames->entries(); i++)
	{
		FMEString S;
		if (!feature.getAttribute((*m_HeaderAttributeNames)(i),*S)) return kMsgInternalError;
		m_HeaderAttributeValues->append(*S);
	}

	FMEStringArray V;
	CUIntArray A;
	// Remove all attributes not starting with H and sort!
	for (unsigned int i = 0; i<m_HeaderAttributeNames->entries(); i++)
	{
		CString S((*m_HeaderAttributeNames)(i));
		int D;
		if (sscanf(S,"H%d",&D)==1)
		{
			A.Add(D);
			V->append((*m_HeaderAttributeValues)(i));
		}
	}

	// Add the attributes that we MUST write to the map - don't care about the values
	// since the value will be synthesized. It doesn't matter if an attribute is already present
	A.Add(4); V->append("");
	A.Add(5); V->append("");
	A.Add(41); V->append("");
	A.Add(57); V->append("");
	A.Add(59); V->append("");

	// Now search for all header attributes (0-100) to place in correct order
	m_HeaderAttributeNames->clear();
	m_HeaderAttributeValues->clear();

	for (unsigned int Index = 0; Index<100; Index++)
	{
		for (unsigned int i = 0; i<V->entries(); i++)
		{
			if (A[i]==Index)
			{
				CString S;
				S.Format("H%d",Index);
				m_HeaderAttributeNames->append(S);
				m_HeaderAttributeValues->append((*V)(i));
				break; // Don't search any further!
			}
		}
	}

	// Set flag to indicate that a header has been processed
	m_bHeaderAlreadyProcessed = true;
	return 0;
}

void DSFLWriter::WriteAttributeValuePair(CString A,CString V)
{
	m_TempOutput.WriteString("%"+A);
	if (!V.IsEmpty()) m_TempOutput.WriteString(" "+V);
	m_TempOutput.WriteString("\n");
}

// Convert and emit attribute
FME_MsgNum DSFLWriter::EmitDSFLAttributes(const IFMEFeature& feature, bool bIncludeClass)
{
	if (bIncludeClass)
	{
		// Must find DSFL_CLASS and DSFL_SUBCLASS attributes
		FMEString DSFLClass;
		FMEString DSFLSubClass;

		if (!feature.getAttribute("dsfl_class",*DSFLClass)) return kMsgNoDSFLClass;
		if (!feature.getAttribute("dsfl_subclass",*DSFLSubClass)) return kMsgNoDSFLSubClass;

		// Compare new class and subclass to previous subclass
		if	(
			(CString(*DSFLClass).CompareNoCase(m_LastDSFLClass)!=0) ||
			(CString(*DSFLSubClass).CompareNoCase(m_LastDSFLSubClass)!=0)
			)
		{
			// We have a change in state - must write
			CString M;
			M.Format("%%%s %%%s\n",(LPCSTR) *DSFLClass,(LPCSTR) *DSFLSubClass);
			m_TempOutput.WriteString(M);

			// Save
			m_LastDSFLClass = CString(*DSFLClass);
			m_LastDSFLSubClass = CString(*DSFLSubClass);
		}
		else
		{
			TRACE("Ho\n");
		}
	}


	// Get list of all attributes names
	FMEStringArray A;
	feature.getAllAttributeNames(*A);

	// Reduce to the list of attributes that we care about (D<XXX>)
	 // and place in an Attribute/Value map
	CMapStringToString CurrentAttributes;
	for (unsigned int i = 0; i<A->entries(); i++)
	{
		int dummy;
		if (sscanf((*A)(i),"D%d",&dummy)==1) 
		{
			FMEString V;
			if (!feature.getAttribute((*A)(i),*V)) return kMsgInternalError;
			CurrentAttributes.SetAt((*A)(i),*V);
			TRACE("Added %s,%s to current\n",(*A)(i),(LPCSTR) *V);
		}
		else
		{
			// Added in build 6: If we have a "dsfl_origin_record_index" attribute, then
			// *rename* this to "N" and treat as any other attribute we care about
			CString attributeName((*A)(i));
			if (attributeName.CompareNoCase("dsfl_origin_record_index")==0)
			{
				// Must get the attribute value
				FMEString V;
				if (!feature.getAttribute((*A)(i),*V)) return kMsgInternalError;

				// Now rename and put into the attribute/value map
				CurrentAttributes.SetAt("N",*V);
			}
		}
	}

	// Scan all attributes and compare with the previously written attributes. If an attribute
	// has a new value (or has not already been included in the map), then write it.

	// Build 8: The following duplicated does not look very nice, be we any %N attribute to be processed
	// and written before all other attributes
	
	POSITION p = CurrentAttributes.GetStartPosition();
	while (p!=NULL)
	{
		CString A,V;
		CurrentAttributes.GetNextAssoc(p,A,V);
		TRACE("Processing current attribute %s,%s\n",A,V);

		if (A.Left(1).CompareNoCase("N")==0)
		{
			// Lookup the attribute/value pair in the static list
			CString S;
			if (!m_AttributeMap.Lookup(A,S))
			{
				TRACE("Not found in map - Writing\n");
				m_AttributeMap.SetAt(A,V); // Not found in map - add to map and write
				WriteAttributeValuePair(A,V);
			}
			else
			{
				TRACE("Found in map\n");
				// Found in map - compare:
				if (S.CompareNoCase(V)!=0)
				{
					TRACE("Different value - writing\n");
					//Different! Set in map and write
					m_AttributeMap.SetAt(A,V); // Not found in map - add to map and write
					WriteAttributeValuePair(A,V);
				}
			}
		}
	}

	// Now iterate the static map to see if any attributes are missing at this time
	p = m_AttributeMap.GetStartPosition();
	while (p!=NULL)
	{
		CString A,V;
		m_AttributeMap.GetNextAssoc(p,A,V);
		TRACE("Processing static attribute %s,%s\n",A,V);

		if (A.Left(1).CompareNoCase("N")==0)
		{
			// Check if the attribute is included
			CString S;
			if (!CurrentAttributes.Lookup(A,S))
			{
				TRACE("Static attribute not present - removing from map\n");
				// We have a static attribute that isn't included in the current set of attribute
				// Write an "empty" attribute/value pair and remove from the map!
				WriteAttributeValuePair(A,"");
				m_AttributeMap.RemoveKey(A);
			}
		}
	}

	// Now repeat the process for all other attributes
	p = CurrentAttributes.GetStartPosition();
	while (p!=NULL)
	{
		CString A,V;
		CurrentAttributes.GetNextAssoc(p,A,V);
		TRACE("Processing current attribute %s,%s\n",A,V);

		if (A.Left(1).CompareNoCase("N")!=0) // Observe the changed condition
		{
			// Lookup the attribute/value pair in the static list
			CString S;
			if (!m_AttributeMap.Lookup(A,S))
			{
				TRACE("Not found in map - Writing\n");
				m_AttributeMap.SetAt(A,V); // Not found in map - add to map and write
				WriteAttributeValuePair(A,V);
			}
			else
			{
				TRACE("Found in map\n");
				// Found in map - compare:
				if (S.CompareNoCase(V)!=0)
				{
					TRACE("Different value - writing\n");
					//Different! Set in map and write
					m_AttributeMap.SetAt(A,V); // Not found in map - add to map and write
					WriteAttributeValuePair(A,V);
				}
			}
		}
	}

	// Same stuff
	p = m_AttributeMap.GetStartPosition();
	while (p!=NULL)
	{
		CString A,V;
		m_AttributeMap.GetNextAssoc(p,A,V);
		TRACE("Processing static attribute %s,%s\n",A,V);

		if (A.Left(1).CompareNoCase("N")!=0) // Observe the changed condition
		{
			// Check if the attribute is included
			CString S;
			if (!CurrentAttributes.Lookup(A,S))
			{
				TRACE("Static attribute not present - removing from map\n");
				// We have a static attribute that isn't included in the current set of attribute
				// Write an "empty" attribute/value pair and remove from the map!
				WriteAttributeValuePair(A,"");
				m_AttributeMap.RemoveKey(A);
			}
		}
	}

	return 0;
}

FME_MsgNum DSFLWriter::ProcessDSFLPoint(const IFMEFeature& feature)
{
	// Translate the point into DSFL points
	WriteFeatureCoordinates("%P1K",feature);
	return 0;
}

FME_MsgNum DSFLWriter::ProcessDSFLLine(const IFMEFeature& feature, bool bFirstPart)
{
	// Translate the line into DSFL lines
	if (bFirstPart) WriteFeatureCoordinates("%L1KR",feature);
	else WriteFeatureCoordinates("%L2KR",feature);
	return 0;
}

void DSFLWriter::WriteFeatureCoordinates(CString Intro, const IFMEFeature& feature)
{
	double X,Y,Z;

	// Creating padding string
	CString Pad(' ',Intro.GetLength());

	for (unsigned int i = 0; i < feature.numCoords(); i++)
	{
		CString S;
		if (feature.getDimension()==3) 
		{
			feature.getCoordinate(i,X,Y,Z);
			ExpandBBox(X,Y,Z);
			if (i==0) 
				S.Format("%s %.3lf %.3lf %.3lf\n",Intro,X,Y,Z);
			else
				S.Format("%s %.3lf %.3lf %.3lf\n",Pad,X,Y,Z);
		}
		else
		{
			feature.getCoordinate(i,X,Y);
			ExpandBBox(X,Y,0.0);
			if (i==0) 
				S.Format("%s %.3lf %.3lf\n",Intro,X,Y);
			else
				S.Format("%s %.3lf %.3lf\n",Pad,X,Y);
		}
		m_TempOutput.WriteString(S);
	}
}

FME_MsgNum DSFLWriter::ProcessDSFLArc(const IFMEFeature& feature)
{
	WriteFeatureCoordinates("%L1KC",feature);
	return 0;
}

FME_MsgNum DSFLWriter::ProcessDSFLPolygon(const IFMEFeature& feature, bool bFirstPart)
{
	// Handle the cases where the FME geometry is fme_polygon or fme_donut
	FMEString S;
	if (!feature.getAttribute("fme_geometry",*S)) return kMsgCantIdentifyFMEGeometry;

	// Check for FME_POLYGON
	CString Geometry(*S);
	if (Geometry.CompareNoCase("fme_polygon")==0)
	{
		// Check for the case where this is not the first part of an aggregate
		if (bFirstPart) WriteFeatureCoordinates("%F1KR",feature);
		else WriteFeatureCoordinates("%F2KR",feature);
		return 0;
	}

	// Check for donut case
	if (Geometry.CompareNoCase("fme_donut")==0)
	{
		IFMEFeatureVector *V = CreateFeatureVector();

		// Get the parts of the donut
		FME_MsgNum R = feature.getDonutParts(*V); 
		if (R!=0) return R;

		// Iterate all parts (first part is the outer ring)
		for (unsigned int i = 0; i<V->entries(); i++)
		{
			if (i==0)
			{
				if (bFirstPart) WriteFeatureCoordinates("%F1KR",*(*V)(i));
				else WriteFeatureCoordinates("%F2KR",*(*V)(i));
			}
			else WriteFeatureCoordinates("%F4KR",*(*V)(i));
		}
	
		// Clean up and return
		NukeFeatureVector(V);
		return 0;
	}

	// If we get this far, we have an unsupported fme geometry for dsfl_polygon
	return kMsgUnsupportedPolygonGeometry;
}	

FME_MsgNum DSFLWriter::ProcessDSFLAggregate(const IFMEFeature& feature, bool bFirstPart)
{
	// Check the FME geometry - make sure it is fme_aggregate
	FMEString S;
	if (!feature.getAttribute("fme_geometry",*S)) return kMsgCantIdentifyFMEGeometry;
	
	// Check for fme_aggregate
	CString Geometry(*S);
	if (Geometry.CompareNoCase("fme_aggregate")==0)
	{
		// We have an aggregate - create a feature vector and split it up!
		IFMEFeatureVector *V = CreateFeatureVector();

		// Split aggregate feature
		FME_MsgNum R = feature.splitAggregate(*V); 
		if (R!=0) return R;

		// iterate all features
		R = 0;
		for (unsigned i = 0; i<V->entries() && (R==0); i++)
		{
			if (!(*V)(i)->getAttribute("fme_geometry",S)) return kMsgCantIdentifyFMEGeometry;
			Geometry = CString(*S);

			if (Geometry.CompareNoCase("fme_donut")==0) 
			{
				R = ProcessDSFLPolygon(*(*V)(i),(bFirstPart && (i==0)));
			}
			else if (Geometry.CompareNoCase("fme_polygon")==0) 
			{
				R = ProcessDSFLPolygon(*(*V)(i),(bFirstPart && (i==0)));
			}
			else if (Geometry.CompareNoCase("fme_aggregate")==0) 
			{
				R = ProcessDSFLAggregate(*(*V)(i),(bFirstPart && (i==0))); // Recurse!
			} 
			else if (Geometry.CompareNoCase("fme_line")==0) 
			{
				R = ProcessDSFLLine(*(*V)(i),(bFirstPart && (i==0))); // Recurse!
			} 
			else
			{
				// If we get this far, we have a problem
				R = kMsgUnexpectedAggregateGeometry;
			}
		}

		NukeFeatureVector(V);
		return R;
	}

	return kMsgExpectedFMEAggregate;
}

FME_MsgNum DSFLWriter::ProcessDSFLText(const IFMEFeature& feature)
{
	// 1) Identify text attribute and emit headers excluding this attribute
	// 2) Translate DSFL rotation into %VV
	// 3) Write text attribute
	// 4) Translate DSFL text justification and point cordinate into %T

	// Initial validation: Make sure that the fme geometry is fme_point
	FMEString S;
	if (!feature.getAttribute("fme_geometry",*S)) return kMsgCantIdentifyFMEGeometry;

	CString Geometry(*S);
	if (Geometry.CompareNoCase("fme_point")!=0) return kMsgExpectedFMEPointForDSFLText;

	if (!feature.getAttribute("dsfl_text_value",*S)) return kMsgMissingTextValue;
	CString TextValue(*S);

	if (!feature.getAttribute("dsfl_text_code",*S)) return kMsgMissingTextCode;
	CString TextCode(*S);

	// Before emitting attributes - If we have a D<X> attribute identical to the TextCode,
	// then add this to the map. This will prevent the text code from being emitted during
	// the standard dump of attributes:
	FMEString Dummy;
	if (feature.getAttribute(TextCode,*Dummy))
	{
		m_AttributeMap.SetAt(TextCode,TextValue);
	}

	FME_MsgNum R = EmitDSFLAttributes(feature,false); //  NO DSFL class or subclass
	if (R!=0) return R;

	// Translate dsfl_text_width and dsfl_text_size into TT5 and TT6 attributes
	if (feature.getAttribute("dsfl_text_width",S))
	{
		CString TextWidth(*S);
		// Only write if the attribute is different from previous
		if (TextWidth.CompareNoCase(m_LastTextWidth)!=0)
		{
			m_LastTextWidth = TextWidth;
			m_TempOutput.WriteString("%TT6 "+TextWidth+"\n");
		}
	}
	if (feature.getAttribute("dsfl_text_size",*S))
	{
		CString TextSize(*S);
		if (TextSize.CompareNoCase(m_LastTextSize)!=0)
		{
			m_LastTextSize = TextSize;
			m_TempOutput.WriteString("%TT5 "+TextSize+"\n");
		}
	}

	// Get DSFL rotation (If we can't get this attribute, use a default value of 200 gon)
	if (!feature.getAttribute("dsfl_rotation",*S))
	{
		CString F("200");
		if (F.CompareNoCase(m_LastRotation)!=0)
		{
			m_LastRotation = F;	
			m_TempOutput.WriteString("%VV "+F+"\n");
		}
	}
	else
	{
		// Convert from degrees to gon
		double D;
		if (sscanf(CString(*S),"%lf",&D)!=1) return kMsgInternalError;
		
		// Convert from degrees to gon
		D = D*400.0/360.0;

		// Change orientation
		if (D<=200) 
			D = 200-D;
		else 
			D = 600-D;

		// And convert to string
		CString F;
		F.Format("%.1lf",D);

		// Write only if different than last time around
		if (F.CompareNoCase(m_LastRotation)!=0)
		{
			m_LastRotation = F;	
			m_TempOutput.WriteString("%VV "+F+"\n");
		}
	}

	// Then write the text value
	m_TempOutput.WriteString("%"+TextCode+" "+TextValue+"\n");

	// Get DSFL text justification (use default value if we cant find the attribute)
	CString Justification = "7"; // set a default value!

	if (feature.getAttribute("dsfl_text_justification",*S))
	{
		CString J(*S);
		if (J.CompareNoCase("dsfl_top_left")==0) Justification = "1";
		if (J.CompareNoCase("dsfl_top_center")==0) Justification = "2";
		if (J.CompareNoCase("dsfl_top_right")==0) Justification = "3";
		if (J.CompareNoCase("dsfl_middle_left")==0) Justification = "4";
		if (J.CompareNoCase("dsfl_middle_center")==0) Justification = "5";
		if (J.CompareNoCase("dsfl_middle_right")==0) Justification = "6";
		if (J.CompareNoCase("dsfl_bottom_left")==0) Justification = "7";
		if (J.CompareNoCase("dsfl_bottom_center")==0) Justification = "8";
		if (J.CompareNoCase("dsfl_bottom_right")==0) Justification = "9";
	}

	// Write text command and coordinates
	WriteFeatureCoordinates("%T"+Justification+" ",feature);

	// If the current text attribute has not been added to the map (because no similar D%
	// was present), then reset the attribute manually
	if (!feature.getAttribute(TextCode,*Dummy))
	{
		m_TempOutput.WriteString("%"+TextCode+"\n");
	}

	return 0;
}

// Write the origin info 
FME_MsgNum DSFLWriter::WriteDSFLOriginInfo()
{
	// Simple iterate the origin info map. Output has already been formatted
	POSITION p = m_OriginInfo.GetStartPosition();
	while (p!=NULL)
	{
		CString Index,Value;
		m_OriginInfo.GetNextAssoc(p,Index,Value);
		m_Output.WriteString(Value); // The complete %RN statement has been created!
	}
	return 0;
}


FME_MsgNum DSFLWriter::WriteDSFLHeader()
{
	// Write DSFL header. Dump all header attributes starting with H<X>, except for the following that are
	// synthesized:

	// %H4 - Bounding box minimum (and we must find a H3 attribute that indicates the order or coordinates)
	// %H5 - Bounding box maximum
	// %H41 - Time of creation
	// &H57 - Writer identification
	// %H59 - Format version date

	// It may be assumed that these attributes are always created during preprocessing
	// and it may be assumed that the header attributes have been sorted!

	// Before doing all this - scan the mapping file for any header directives in the
	// format DSFLW_H<X> <Value> and insert these at the correct positions in the
	// list of header attributes.

	for (unsigned int i = 0; i<100; i++)
	{
		CString KW;
		KW.Format("H%d",i);
		FMEString V;

		if (gMappingFile->fetchWithPrefix(*writerKeyword_, *writerTypeName_,KW,*V))
		{
			V->decodeFromFMEParsableText();
			// We found a directive - now insert at correct place in the list
			bool bInserted = false;
			for (unsigned y = 0; y<m_HeaderAttributeNames->entries(); y++)
			{
				CString N = (*m_HeaderAttributeNames)(y);
				unsigned int D;
				if (sscanf(N,"H%d",&D)==1)
				{
					if (D==i)
					{
						// Replace existing!
						m_HeaderAttributeValues->setElement(y,*V);
						bInserted = true;
						break;
					}
					else
					{
						// Check if we should insert before the current position
						if (i<D)
						{
							// We should
							bInserted = true;

							// Append dummy string and move down
							m_HeaderAttributeValues->append("");
							m_HeaderAttributeNames->append("");

							for (unsigned int z=m_HeaderAttributeValues->entries()-1; z>=y+1; z--)
							{
								FMEString CV,CN;
								*CV = (*m_HeaderAttributeValues)(z-1);
								*CN = (*m_HeaderAttributeNames)(z-1);
								m_HeaderAttributeValues->setElement(z,*CV);
								m_HeaderAttributeNames->setElement(z,*CN);
							}

							// Insert new attribute
							m_HeaderAttributeValues->setElement(y,*V);
							FMEString CN(KW);
							m_HeaderAttributeNames->setElement(y,CN);
							break;
						}
					}
				}
			}
			// If we haven't inserted yet, then append
			if (!bInserted)
			{
				m_HeaderAttributeValues->append(*V);
				m_HeaderAttributeNames->append(KW);
			}
		}
	}

	for (unsigned int i = 0; i<m_HeaderAttributeNames->entries(); i++)
	{
		CString N = (*m_HeaderAttributeNames)(i);
		CString V = (*m_HeaderAttributeValues)(i);
		int D;
		if (sscanf(N,"H%d",&D)==1)
		{
			switch(D)
			{
				case 3:
				// This is a bugfix: If we haven't processed a dsfl_header, then m_CoordinateOrder is empty.
				// If we meet a H3 statement in this situation, then use this value (from the mapping directives)
				if (m_CoordinateOrder.GetLength()==0)
				{
					m_CoordinateOrder = V;
				}

				// In all cases, write the attribute
				m_Output.WriteString("%"+N+" "+V+"\n");
				break;	

				case 4: // Bounding box maximum
				{
					CString F;

					// Check if we should write a 2D or a 3D bounding box
					if (m_CoordinateOrder.GetLength()==3)
					{
						// 3D
						F.Format("%%H4 %.3lf %.3lf %.3lf\n",m_Xmax,m_Ymax,m_Zmax);
					}
					else
					{
						// 2D
						F.Format("%%H4 %.3lf %.3lf\n",m_Xmax,m_Ymax);
					}
					m_Output.WriteString(F);
				}
				break;

				case 5: // Bounding box minimum
				{
					CString F;

					// Check if we should write a 2D or a 3D bounding box
					if (m_CoordinateOrder.GetLength()==3)
					{
						// 3D
						F.Format("%%H5 %.3lf %.3lf %.3lf\n",m_Xmin,m_Ymin,m_Zmin);
					}
					else
					{
						// 2D
						F.Format("%%H5 %.3lf %.3lf\n",m_Xmin,m_Ymin);
					}
					m_Output.WriteString(F);
				}
				break;

				case 41: // Time of file creation
				{
					CTime T = CTime::GetCurrentTime();
					m_Output.WriteString("%H41 "+T.Format("%y%m%d %H%M")+"\n");
				}
				break;

				case 57: // Writer version ID
				m_Output.WriteString("%H57 "+ CString(VERSIONID)+"\n");
				break;

				case 59: // Format identification
				m_Output.WriteString("%H59 950601\n");
				break;

				default:
				// Write attribute with no conversion
				m_Output.WriteString("%"+N+" "+V+"\n");
			}
		}
	}
	return 0;
}


DSFLWriter::~DSFLWriter()
{
}

FME_MsgNum DSFLWriter::open(const char* datasetName,
                            const IFMEStringArray& parameters)
{
	// Log version ID
	Msg(kMsgStringFormatter,"%s",VERSIONID);

	// If this was a multi-writer, the code should go like this:
	// Must create an output file name from datasetName (folder) and parameter 0!
	// m_DataSetName = CString(datasetName)+CString(parameters(0))+".dsf";
	
	// But the multi-writer features doesn't seem to work as described. In stead,
	// we use the standard approach:
	m_DataSetName = CString(datasetName);

	// Open temporary as well as permanent output file
	int P = m_DataSetName.ReverseFind('.');
	if (P==-1) return kMsgCantCreateTempFileName;
	m_TempFileName = m_DataSetName.Left(P)+".tmp";
	
	if (!m_Output.Open(m_DataSetName,CFile::modeReadWrite | CFile::modeCreate | CFile::shareDenyNone))
	{
		return kMsgCantCreateOutputFile;
	}

	if (!m_TempOutput.Open(m_TempFileName,CFile::modeReadWrite | CFile::modeCreate))
	{
		return kMsgCantCreateTempOutputFile;
	}

	// Reset bounding box information
	ResetBBox();

	return 0;
}

FME_MsgNum DSFLWriter::abort()
{
	 return 0;
}


FME_MsgNum DSFLWriter::close()
{
	// If no points has been processed, then don't bother to write anything
	if (!m_bPointProcessed) return kMsgNoData;

	// Must first write header
	FME_MsgNum R = WriteDSFLHeader();
	if (R!=0) return R;

	// Write origin information
	R = WriteDSFLOriginInfo();
	if (R!=0) return R;

	// Then copy contents of temporary file to permanent file
	m_TempOutput.SeekToBegin();
	CString S;
	while (m_TempOutput.ReadString(S)) m_Output.WriteString(S+"\n");

	// Write end of file
	m_Output.WriteString("%D\n"); // Reset all attributes
	m_Output.WriteString("%S\n");

	// Done close both files and delete temporary output file
	m_TempOutput.Close();
	m_Output.Close();

	::DeleteFile(m_TempFileName);

	// And return
    return 0;
}

 FME_MsgNum DSFLWriter::write(const IFMEFeature& feature)
{
	// Get feature type
	FMEString featureType;
	feature.getFeatureType(*featureType);
	if (feature.getGeometryType() == FME_GEOM_AGGREGATE)
	{
		*featureType = "dsfl_aggregate";
	}
	else
	{
		feature.getAttribute("dsfl_type",*featureType);
	}

	CString S(*featureType);

	// Msg(kMsgFeatureType,"%s",S);

	// Branch on selected feature.
	if (S.CompareNoCase("dsfl_header")==0) 
	{
		// Don't emit any headers for the header!
		return ProcessDSFLHeader(feature);
	}

	// Check for dsfl_origin feature and build map of origin info (added in build 6)
	if (S.CompareNoCase("dsfl_origin")==0) 
	{
		// Don't emit any headers for the header!
		return ProcessDSFLOrigin(feature);
	}

	if (S.CompareNoCase("dsfl_none")==0) 
	{
		// Emit headers and do no further processing
		return EmitDSFLAttributes(feature,true);
	}

	if (S.CompareNoCase("dsfl_point")==0) 
	{
		// Emit headers
		FME_MsgNum R = EmitDSFLAttributes(feature,true);
		if (R!=0) return R;
		return ProcessDSFLPoint(feature);
	}

	if (S.CompareNoCase("dsfl_line")==0) 
	{
		// Emit headers
		FME_MsgNum R = EmitDSFLAttributes(feature,true);
		if (R!=0) return R;
		return ProcessDSFLLine(feature,true);
	}

	if (S.CompareNoCase("dsfl_arc")==0) 
	{
		// Emit headers
		FME_MsgNum R = EmitDSFLAttributes(feature,true);
		if (R!=0) return R;
		return ProcessDSFLArc(feature);
	}

	if (S.CompareNoCase("dsfl_text")==0) 
	{
		// Don't emit headers at this time - we need to identify the actual text attribute
		// so that this attribute may be written individually
		return ProcessDSFLText(feature);
	}

	if (S.CompareNoCase("dsfl_polygon")==0) 
	{
		// Emit headers
		FME_MsgNum R = EmitDSFLAttributes(feature,true);
		if (R!=0) return R;
		return ProcessDSFLPolygon(feature,true);
	}

	if (S.CompareNoCase("dsfl_aggregate")==0) 
	{
		// Emit headers
		FME_MsgNum R = EmitDSFLAttributes(feature,true);
		if (R!=0) return R;
		return ProcessDSFLAggregate(feature,true);
	}

	// We have an unsupported feature
	return kMsgUnsupportedFeatureType; 
}
                           
FME_Boolean DSFLWriter::multiFileWriter() const
{
    // return FME_TRUE; // Yes, this is a multi-file writer!
	return FME_FALSE;
}

